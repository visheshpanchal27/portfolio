{"ast":null,"code":"const radToDeg = rad => rad * 180 / Math.PI;\nconst rotate = v => {\n  const angle = radToDeg(Math.atan2(v[1], v[0]));\n  return rebaseAngle(angle);\n};\nconst matrix2dParsers = {\n  x: 4,\n  y: 5,\n  translateX: 4,\n  translateY: 5,\n  scaleX: 0,\n  scaleY: 3,\n  scale: v => (Math.abs(v[0]) + Math.abs(v[3])) / 2,\n  rotate,\n  rotateZ: rotate,\n  skewX: v => radToDeg(Math.atan(v[1])),\n  skewY: v => radToDeg(Math.atan(v[2])),\n  skew: v => (Math.abs(v[1]) + Math.abs(v[2])) / 2\n};\nconst rebaseAngle = angle => {\n  angle = angle % 360;\n  if (angle < 0) angle += 360;\n  return angle;\n};\nconst rotateZ = rotate;\nconst scaleX = v => Math.sqrt(v[0] * v[0] + v[1] * v[1]);\nconst scaleY = v => Math.sqrt(v[4] * v[4] + v[5] * v[5]);\nconst matrix3dParsers = {\n  x: 12,\n  y: 13,\n  z: 14,\n  translateX: 12,\n  translateY: 13,\n  translateZ: 14,\n  scaleX,\n  scaleY,\n  scale: v => (scaleX(v) + scaleY(v)) / 2,\n  rotateX: v => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),\n  rotateY: v => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),\n  rotateZ,\n  rotate: rotateZ,\n  skewX: v => radToDeg(Math.atan(v[4])),\n  skewY: v => radToDeg(Math.atan(v[1])),\n  skew: v => (Math.abs(v[1]) + Math.abs(v[4])) / 2\n};\nfunction defaultTransformValue(name) {\n  return name.includes(\"scale\") ? 1 : 0;\n}\nfunction parseValueFromTransform(transform, name) {\n  if (!transform || transform === \"none\") {\n    return defaultTransformValue(name);\n  }\n  const matrix3dMatch = transform.match(/^matrix3d\\(([-\\d.e\\s,]+)\\)$/u);\n  let parsers;\n  let match;\n  if (matrix3dMatch) {\n    parsers = matrix3dParsers;\n    match = matrix3dMatch;\n  } else {\n    const matrix2dMatch = transform.match(/^matrix\\(([-\\d.e\\s,]+)\\)$/u);\n    parsers = matrix2dParsers;\n    match = matrix2dMatch;\n  }\n  if (!match) {\n    return defaultTransformValue(name);\n  }\n  const valueParser = parsers[name];\n  const values = match[1].split(\",\").map(convertTransformToNumber);\n  return typeof valueParser === \"function\" ? valueParser(values) : values[valueParser];\n}\nconst readTransformValue = (instance, name) => {\n  const {\n    transform = \"none\"\n  } = getComputedStyle(instance);\n  return parseValueFromTransform(transform, name);\n};\nfunction convertTransformToNumber(value) {\n  return parseFloat(value.trim());\n}\nexport { parseValueFromTransform, readTransformValue };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}