{"ast":null,"code":"import { NativeAnimationControls, isGenerator, createGeneratorEasing, supportsLinearEasing } from 'motion-dom';\nimport { invariant, secondsToMilliseconds } from 'motion-utils';\nimport { startWaapiAnimation } from './index.mjs';\nimport { browserNumberValueTypes } from '../../../render/dom/value-types/number-browser.mjs';\nimport { getFinalKeyframe } from './utils/get-final-keyframe.mjs';\nimport { setCSSVar, setStyle } from './utils/style.mjs';\nimport { supportsPartialKeyframes } from './utils/supports-partial-keyframes.mjs';\nimport { supportsWaapi } from './utils/supports-waapi.mjs';\nconst state = new WeakMap();\nfunction hydrateKeyframes(valueName, keyframes, read) {\n  for (let i = 0; i < keyframes.length; i++) {\n    if (keyframes[i] === null) {\n      keyframes[i] = i === 0 ? read() : keyframes[i - 1];\n    }\n    if (typeof keyframes[i] === \"number\" && browserNumberValueTypes[valueName]) {\n      keyframes[i] = browserNumberValueTypes[valueName].transform(keyframes[i]);\n    }\n  }\n  if (!supportsPartialKeyframes() && keyframes.length < 2) {\n    keyframes.unshift(read());\n  }\n}\nconst defaultEasing = \"easeOut\";\nfunction getElementAnimationState(element) {\n  const animationState = state.get(element) || new Map();\n  state.set(element, animationState);\n  return state.get(element);\n}\nclass NativeAnimation extends NativeAnimationControls {\n  constructor(element, valueName, valueKeyframes, options) {\n    const isCSSVar = valueName.startsWith(\"--\");\n    invariant(typeof options.type !== \"string\", `animateMini doesn't support \"type\" as a string. Did you mean to import { spring } from \"framer-motion\"?`);\n    const existingAnimation = getElementAnimationState(element).get(valueName);\n    existingAnimation && existingAnimation.stop();\n    const readInitialKeyframe = () => {\n      return valueName.startsWith(\"--\") ? element.style.getPropertyValue(valueName) : window.getComputedStyle(element)[valueName];\n    };\n    if (!Array.isArray(valueKeyframes)) {\n      valueKeyframes = [valueKeyframes];\n    }\n    hydrateKeyframes(valueName, valueKeyframes, readInitialKeyframe);\n    // TODO: Replace this with toString()?\n    if (isGenerator(options.type)) {\n      const generatorOptions = createGeneratorEasing(options, 100, options.type);\n      options.ease = supportsLinearEasing() ? generatorOptions.ease : defaultEasing;\n      options.duration = secondsToMilliseconds(generatorOptions.duration);\n      options.type = \"keyframes\";\n    } else {\n      options.ease = options.ease || defaultEasing;\n    }\n    const onFinish = () => {\n      this.setValue(element, valueName, getFinalKeyframe(valueKeyframes, options));\n      this.cancel();\n      this.resolveFinishedPromise();\n    };\n    const init = () => {\n      this.setValue = isCSSVar ? setCSSVar : setStyle;\n      this.options = options;\n      this.updateFinishedPromise();\n      this.removeAnimation = () => {\n        const elementState = state.get(element);\n        elementState && elementState.delete(valueName);\n      };\n    };\n    if (!supportsWaapi()) {\n      super();\n      init();\n      onFinish();\n    } else {\n      super(startWaapiAnimation(element, valueName, valueKeyframes, options));\n      init();\n      if (options.autoplay === false) {\n        this.animation.pause();\n      }\n      this.animation.onfinish = onFinish;\n      getElementAnimationState(element).set(valueName, this);\n    }\n  }\n  /**\n   * Allows the returned animation to be awaited or promise-chained. Currently\n   * resolves when the animation finishes at all but in a future update could/should\n   * reject if its cancels.\n   */\n  then(resolve, reject) {\n    return this.currentFinishedPromise.then(resolve, reject);\n  }\n  updateFinishedPromise() {\n    this.currentFinishedPromise = new Promise(resolve => {\n      this.resolveFinishedPromise = resolve;\n    });\n  }\n  play() {\n    if (this.state === \"finished\") {\n      this.updateFinishedPromise();\n    }\n    super.play();\n  }\n  cancel() {\n    this.removeAnimation();\n    super.cancel();\n  }\n}\nexport { NativeAnimation };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}