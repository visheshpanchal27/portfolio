{"ast":null,"code":"import { frame } from 'motion-dom';\nimport { removeNonTranslationalTransform } from '../dom/utils/unit-conversion.mjs';\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nfunction measureAllKeyframes() {\n  if (anyNeedsMeasurement) {\n    const resolversToMeasure = Array.from(toResolve).filter(resolver => resolver.needsMeasurement);\n    const elementsToMeasure = new Set(resolversToMeasure.map(resolver => resolver.element));\n    const transformsToRestore = new Map();\n    /**\n     * Write pass\n     * If we're measuring elements we want to remove bounding box-changing transforms.\n     */\n    elementsToMeasure.forEach(element => {\n      const removedTransforms = removeNonTranslationalTransform(element);\n      if (!removedTransforms.length) return;\n      transformsToRestore.set(element, removedTransforms);\n      element.render();\n    });\n    // Read\n    resolversToMeasure.forEach(resolver => resolver.measureInitialState());\n    // Write\n    elementsToMeasure.forEach(element => {\n      element.render();\n      const restore = transformsToRestore.get(element);\n      if (restore) {\n        restore.forEach(([key, value]) => {\n          var _a;\n          (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);\n        });\n      }\n    });\n    // Read\n    resolversToMeasure.forEach(resolver => resolver.measureEndState());\n    // Write\n    resolversToMeasure.forEach(resolver => {\n      if (resolver.suspendedScrollY !== undefined) {\n        window.scrollTo(0, resolver.suspendedScrollY);\n      }\n    });\n  }\n  anyNeedsMeasurement = false;\n  isScheduled = false;\n  toResolve.forEach(resolver => resolver.complete());\n  toResolve.clear();\n}\nfunction readAllKeyframes() {\n  toResolve.forEach(resolver => {\n    resolver.readKeyframes();\n    if (resolver.needsMeasurement) {\n      anyNeedsMeasurement = true;\n    }\n  });\n}\nfunction flushKeyframeResolvers() {\n  readAllKeyframes();\n  measureAllKeyframes();\n}\nclass KeyframeResolver {\n  constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\n    /**\n     * Track whether this resolver has completed. Once complete, it never\n     * needs to attempt keyframe resolution again.\n     */\n    this.isComplete = false;\n    /**\n     * Track whether this resolver is async. If it is, it'll be added to the\n     * resolver queue and flushed in the next frame. Resolvers that aren't going\n     * to trigger read/write thrashing don't need to be async.\n     */\n    this.isAsync = false;\n    /**\n     * Track whether this resolver needs to perform a measurement\n     * to resolve its keyframes.\n     */\n    this.needsMeasurement = false;\n    /**\n     * Track whether this resolver is currently scheduled to resolve\n     * to allow it to be cancelled and resumed externally.\n     */\n    this.isScheduled = false;\n    this.unresolvedKeyframes = [...unresolvedKeyframes];\n    this.onComplete = onComplete;\n    this.name = name;\n    this.motionValue = motionValue;\n    this.element = element;\n    this.isAsync = isAsync;\n  }\n  scheduleResolve() {\n    this.isScheduled = true;\n    if (this.isAsync) {\n      toResolve.add(this);\n      if (!isScheduled) {\n        isScheduled = true;\n        frame.read(readAllKeyframes);\n        frame.resolveKeyframes(measureAllKeyframes);\n      }\n    } else {\n      this.readKeyframes();\n      this.complete();\n    }\n  }\n  readKeyframes() {\n    const {\n      unresolvedKeyframes,\n      name,\n      element,\n      motionValue\n    } = this;\n    /**\n     * If a keyframe is null, we hydrate it either by reading it from\n     * the instance, or propagating from previous keyframes.\n     */\n    for (let i = 0; i < unresolvedKeyframes.length; i++) {\n      if (unresolvedKeyframes[i] === null) {\n        /**\n         * If the first keyframe is null, we need to find its value by sampling the element\n         */\n        if (i === 0) {\n          const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\n          const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n          if (currentValue !== undefined) {\n            unresolvedKeyframes[0] = currentValue;\n          } else if (element && name) {\n            const valueAsRead = element.readValue(name, finalKeyframe);\n            if (valueAsRead !== undefined && valueAsRead !== null) {\n              unresolvedKeyframes[0] = valueAsRead;\n            }\n          }\n          if (unresolvedKeyframes[0] === undefined) {\n            unresolvedKeyframes[0] = finalKeyframe;\n          }\n          if (motionValue && currentValue === undefined) {\n            motionValue.set(unresolvedKeyframes[0]);\n          }\n        } else {\n          unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\n        }\n      }\n    }\n  }\n  setFinalKeyframe() {}\n  measureInitialState() {}\n  renderEndStyles() {}\n  measureEndState() {}\n  complete() {\n    this.isComplete = true;\n    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\n    toResolve.delete(this);\n  }\n  cancel() {\n    if (!this.isComplete) {\n      this.isScheduled = false;\n      toResolve.delete(this);\n    }\n  }\n  resume() {\n    if (!this.isComplete) this.scheduleResolve();\n  }\n}\nexport { KeyframeResolver, flushKeyframeResolvers };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}