{"ast":null,"code":"import { noop } from 'motion-utils';\nimport { startWaapiAnimation } from '../animators/waapi/index.mjs';\nimport { optimizedAppearDataId } from './data-id.mjs';\nimport { getOptimisedAppearId } from './get-appear-id.mjs';\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\nimport { appearAnimationStore, appearComplete } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\n\n/**\n * A single time to use across all animations to manually set startTime\n * and ensure they're all in sync.\n */\nlet startFrameTime;\n/**\n * A dummy animation to detect when Chrome is ready to start\n * painting the page and hold off from triggering the real animation\n * until then. We only need one animation to detect paint ready.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\n */\nlet readyAnimation;\n/**\n * Keep track of animations that were suspended vs cancelled so we\n * can easily resume them when we're done measuring layout.\n */\nconst suspendedAnimations = new Set();\nfunction resumeSuspendedAnimations() {\n  suspendedAnimations.forEach(data => {\n    data.animation.play();\n    data.animation.startTime = data.startTime;\n  });\n  suspendedAnimations.clear();\n}\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n  // Prevent optimised appear animations if Motion has already started animating.\n  if (window.MotionIsMounted) {\n    return;\n  }\n  const id = element.dataset[optimizedAppearDataId];\n  if (!id) return;\n  window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n  const storeId = appearStoreId(id, name);\n  if (!readyAnimation) {\n    readyAnimation = startWaapiAnimation(element, name, [keyframes[0], keyframes[0]],\n    /**\n     * 10 secs is basically just a super-safe duration to give Chrome\n     * long enough to get the animation ready.\n     */\n    {\n      duration: 10000,\n      ease: \"linear\"\n    });\n    appearAnimationStore.set(storeId, {\n      animation: readyAnimation,\n      startTime: null\n    });\n    /**\n     * If there's no readyAnimation then there's been no instantiation\n     * of handoff animations.\n     */\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n    window.MotionHasOptimisedAnimation = (elementId, valueName) => {\n      if (!elementId) return false;\n      /**\n       * Keep a map of elementIds that have started animating. We check\n       * via ID instead of Element because of hydration errors and\n       * pre-hydration checks. We also actively record IDs as they start\n       * animating rather than simply checking for data-appear-id as\n       * this attrbute might be present but not lead to an animation, for\n       * instance if the element's appear animation is on a different\n       * breakpoint.\n       */\n      if (!valueName) {\n        return appearComplete.has(elementId);\n      }\n      const animationId = appearStoreId(elementId, valueName);\n      return Boolean(appearAnimationStore.get(animationId));\n    };\n    window.MotionHandoffMarkAsComplete = elementId => {\n      if (appearComplete.has(elementId)) {\n        appearComplete.set(elementId, true);\n      }\n    };\n    window.MotionHandoffIsComplete = elementId => {\n      return appearComplete.get(elementId) === true;\n    };\n    /**\n     * We only need to cancel transform animations as\n     * they're the ones that will interfere with the\n     * layout animation measurements.\n     */\n    window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\n      const animationId = appearStoreId(elementId, valueName);\n      const data = appearAnimationStore.get(animationId);\n      if (!data) return;\n      if (frame && canResume === undefined) {\n        /**\n         * Wait until the end of the subsequent frame to cancel the animation\n         * to ensure we don't remove the animation before the main thread has\n         * had a chance to resolve keyframes and render.\n         */\n        frame.postRender(() => {\n          frame.postRender(() => {\n            data.animation.cancel();\n          });\n        });\n      } else {\n        data.animation.cancel();\n      }\n      if (frame && canResume) {\n        suspendedAnimations.add(data);\n        frame.render(resumeSuspendedAnimations);\n      } else {\n        appearAnimationStore.delete(animationId);\n        /**\n         * If there are no more animations left, we can remove the cancel function.\n         * This will let us know when we can stop checking for conflicting layout animations.\n         */\n        if (!appearAnimationStore.size) {\n          window.MotionCancelOptimisedAnimation = undefined;\n        }\n      }\n    };\n    window.MotionCheckAppearSync = (visualElement, valueName, value) => {\n      var _a, _b;\n      const appearId = getOptimisedAppearId(visualElement);\n      if (!appearId) return;\n      const valueIsOptimised = (_a = window.MotionHasOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n      const externalAnimationValue = (_b = visualElement.props.values) === null || _b === void 0 ? void 0 : _b[valueName];\n      if (!valueIsOptimised || !externalAnimationValue) return;\n      const removeSyncCheck = value.on(\"change\", latestValue => {\n        var _a;\n        if (externalAnimationValue.get() !== latestValue) {\n          (_a = window.MotionCancelOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n          removeSyncCheck();\n        }\n      });\n      return removeSyncCheck;\n    };\n  }\n  const startAnimation = () => {\n    readyAnimation.cancel();\n    const appearAnimation = startWaapiAnimation(element, name, keyframes, options);\n    /**\n     * Record the time of the first started animation. We call performance.now() once\n     * here and once in handoff to ensure we're getting\n     * close to a frame-locked time. This keeps all animations in sync.\n     */\n    if (startFrameTime === undefined) {\n      startFrameTime = performance.now();\n    }\n    appearAnimation.startTime = startFrameTime;\n    appearAnimationStore.set(storeId, {\n      animation: appearAnimation,\n      startTime: startFrameTime\n    });\n    if (onReady) onReady(appearAnimation);\n  };\n  appearComplete.set(id, false);\n  if (readyAnimation.ready) {\n    readyAnimation.ready.then(startAnimation).catch(noop);\n  } else {\n    startAnimation();\n  }\n}\nexport { startOptimizedAppearAnimation };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}