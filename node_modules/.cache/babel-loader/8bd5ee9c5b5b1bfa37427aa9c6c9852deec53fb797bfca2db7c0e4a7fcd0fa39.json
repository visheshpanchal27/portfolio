{"ast":null,"code":"\"use client\";\n\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { useMemo, useRef, useState, useContext } from 'react';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { usePresence } from './use-presence.mjs';\nimport { onlyElements, getChildKey } from './utils.mjs';\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({\n  children,\n  custom,\n  initial = true,\n  onExitComplete,\n  presenceAffectsLayout = true,\n  mode = \"sync\",\n  propagate = false,\n  anchorX = \"left\"\n}) => {\n  const [isParentPresent, safeToRemove] = usePresence(propagate);\n  /**\n   * Filter any children that aren't ReactElements. We can only track components\n   * between renders with a props.key.\n   */\n  const presentChildren = useMemo(() => onlyElements(children), [children]);\n  /**\n   * Track the keys of the currently rendered children. This is used to\n   * determine which children are exiting.\n   */\n  const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\n  /**\n   * If `initial={false}` we only want to pass this to components in the first render.\n   */\n  const isInitialRender = useRef(true);\n  /**\n   * A ref containing the currently present children. When all exit animations\n   * are complete, we use this to re-render the component with the latest children\n   * *committed* rather than the latest children *rendered*.\n   */\n  const pendingPresentChildren = useRef(presentChildren);\n  /**\n   * Track which exiting children have finished animating out.\n   */\n  const exitComplete = useConstant(() => new Map());\n  /**\n   * Save children to render as React state. To ensure this component is concurrent-safe,\n   * we check for exiting children via an effect.\n   */\n  const [diffedChildren, setDiffedChildren] = useState(presentChildren);\n  const [renderedChildren, setRenderedChildren] = useState(presentChildren);\n  useIsomorphicLayoutEffect(() => {\n    isInitialRender.current = false;\n    pendingPresentChildren.current = presentChildren;\n    /**\n     * Update complete status of exiting children.\n     */\n    for (let i = 0; i < renderedChildren.length; i++) {\n      const key = getChildKey(renderedChildren[i]);\n      if (!presentKeys.includes(key)) {\n        if (exitComplete.get(key) !== true) {\n          exitComplete.set(key, false);\n        }\n      } else {\n        exitComplete.delete(key);\n      }\n    }\n  }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\n  const exitingChildren = [];\n  if (presentChildren !== diffedChildren) {\n    let nextChildren = [...presentChildren];\n    /**\n     * Loop through all the currently rendered components and decide which\n     * are exiting.\n     */\n    for (let i = 0; i < renderedChildren.length; i++) {\n      const child = renderedChildren[i];\n      const key = getChildKey(child);\n      if (!presentKeys.includes(key)) {\n        nextChildren.splice(i, 0, child);\n        exitingChildren.push(child);\n      }\n    }\n    /**\n     * If we're in \"wait\" mode, and we have exiting children, we want to\n     * only render these until they've all exited.\n     */\n    if (mode === \"wait\" && exitingChildren.length) {\n      nextChildren = exitingChildren;\n    }\n    setRenderedChildren(onlyElements(nextChildren));\n    setDiffedChildren(presentChildren);\n    /**\n     * Early return to ensure once we've set state with the latest diffed\n     * children, we can immediately re-render.\n     */\n    return null;\n  }\n  if (process.env.NODE_ENV !== \"production\" && mode === \"wait\" && renderedChildren.length > 1) {\n    console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n  }\n  /**\n   * If we've been provided a forceRender function by the LayoutGroupContext,\n   * we can use it to force a re-render amongst all surrounding components once\n   * all components have finished animating out.\n   */\n  const {\n    forceRender\n  } = useContext(LayoutGroupContext);\n  return jsx(Fragment, {\n    children: renderedChildren.map(child => {\n      const key = getChildKey(child);\n      const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);\n      const onExit = () => {\n        if (exitComplete.has(key)) {\n          exitComplete.set(key, true);\n        } else {\n          return;\n        }\n        let isEveryExitComplete = true;\n        exitComplete.forEach(isExitComplete => {\n          if (!isExitComplete) isEveryExitComplete = false;\n        });\n        if (isEveryExitComplete) {\n          forceRender === null || forceRender === void 0 ? void 0 : forceRender();\n          setRenderedChildren(pendingPresentChildren.current);\n          propagate && (safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove());\n          onExitComplete && onExitComplete();\n        }\n      };\n      return jsx(PresenceChild, {\n        isPresent: isPresent,\n        initial: !isInitialRender.current || initial ? undefined : false,\n        custom: custom,\n        presenceAffectsLayout: presenceAffectsLayout,\n        mode: mode,\n        onExitComplete: isPresent ? undefined : onExit,\n        anchorX: anchorX,\n        children: child\n      }, key);\n    })\n  });\n};\nexport { AnimatePresence };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}