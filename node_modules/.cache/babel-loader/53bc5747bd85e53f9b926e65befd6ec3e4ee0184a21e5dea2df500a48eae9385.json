{"ast":null,"code":"import { supportsScrollTimeline } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { observeTimeline } from './observe.mjs';\nimport { scrollInfo } from './track.mjs';\nfunction scrollTimelineFallback({\n  source,\n  container,\n  axis = \"y\"\n}) {\n  // Support legacy source argument. Deprecate later.\n  if (source) container = source;\n  // ScrollTimeline records progress as a percentage CSSUnitValue\n  const currentTime = {\n    value: 0\n  };\n  const cancel = scrollInfo(info => {\n    currentTime.value = info[axis].progress * 100;\n  }, {\n    container,\n    axis\n  });\n  return {\n    currentTime,\n    cancel\n  };\n}\nconst timelineCache = new Map();\nfunction getTimeline({\n  source,\n  container = document.documentElement,\n  axis = \"y\"\n} = {}) {\n  // Support legacy source argument. Deprecate later.\n  if (source) container = source;\n  if (!timelineCache.has(container)) {\n    timelineCache.set(container, {});\n  }\n  const elementCache = timelineCache.get(container);\n  if (!elementCache[axis]) {\n    elementCache[axis] = supportsScrollTimeline() ? new ScrollTimeline({\n      source: container,\n      axis\n    }) : scrollTimelineFallback({\n      source: container,\n      axis\n    });\n  }\n  return elementCache[axis];\n}\n/**\n * If the onScroll function has two arguments, it's expecting\n * more specific information about the scroll from scrollInfo.\n */\nfunction isOnScrollWithInfo(onScroll) {\n  return onScroll.length === 2;\n}\n/**\n * Currently, we only support element tracking with `scrollInfo`, though in\n * the future we can also offer ViewTimeline support.\n */\nfunction needsElementTracking(options) {\n  return options && (options.target || options.offset);\n}\nfunction scrollFunction(onScroll, options) {\n  if (isOnScrollWithInfo(onScroll) || needsElementTracking(options)) {\n    return scrollInfo(info => {\n      onScroll(info[options.axis].progress, info);\n    }, options);\n  } else {\n    return observeTimeline(onScroll, getTimeline(options));\n  }\n}\nfunction scrollAnimation(animation, options) {\n  animation.flatten();\n  if (needsElementTracking(options)) {\n    animation.pause();\n    return scrollInfo(info => {\n      animation.time = animation.duration * info[options.axis].progress;\n    }, options);\n  } else {\n    const timeline = getTimeline(options);\n    if (animation.attachTimeline) {\n      return animation.attachTimeline(timeline, valueAnimation => {\n        valueAnimation.pause();\n        return observeTimeline(progress => {\n          valueAnimation.time = valueAnimation.duration * progress;\n        }, timeline);\n      });\n    } else {\n      return noop;\n    }\n  }\n}\nfunction scroll(onScroll, {\n  axis = \"y\",\n  ...options\n} = {}) {\n  const optionsWithDefaults = {\n    axis,\n    ...options\n  };\n  return typeof onScroll === \"function\" ? scrollFunction(onScroll, optionsWithDefaults) : scrollAnimation(onScroll, optionsWithDefaults);\n}\nexport { scroll };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}