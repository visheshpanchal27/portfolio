{"ast":null,"code":"import { getValueTransition, frame, GroupPlaybackControls } from 'motion-dom';\nimport { secondsToMilliseconds, MotionGlobalConfig } from 'motion-utils';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => onComplete => {\n  const valueTransition = getValueTransition(transition, name) || {};\n  /**\n   * Most transition values are currently completely overwritten by value-specific\n   * transitions. In the future it'd be nicer to blend these transitions. But for now\n   * delay actually does inherit from the root transition if not value-specific.\n   */\n  const delay = valueTransition.delay || transition.delay || 0;\n  /**\n   * Elapsed isn't a public transition option but can be passed through from\n   * optimized appear effects in milliseconds.\n   */\n  let {\n    elapsed = 0\n  } = transition;\n  elapsed = elapsed - secondsToMilliseconds(delay);\n  let options = {\n    keyframes: Array.isArray(target) ? target : [null, target],\n    ease: \"easeOut\",\n    velocity: value.getVelocity(),\n    ...valueTransition,\n    delay: -elapsed,\n    onUpdate: v => {\n      value.set(v);\n      valueTransition.onUpdate && valueTransition.onUpdate(v);\n    },\n    onComplete: () => {\n      onComplete();\n      valueTransition.onComplete && valueTransition.onComplete();\n    },\n    name,\n    motionValue: value,\n    element: isHandoff ? undefined : element\n  };\n  /**\n   * If there's no transition defined for this value, we can generate\n   * unique transition settings for this value.\n   */\n  if (!isTransitionDefined(valueTransition)) {\n    options = {\n      ...options,\n      ...getDefaultTransition(name, options)\n    };\n  }\n  /**\n   * Both WAAPI and our internal animation functions use durations\n   * as defined by milliseconds, while our external API defines them\n   * as seconds.\n   */\n  if (options.duration) {\n    options.duration = secondsToMilliseconds(options.duration);\n  }\n  if (options.repeatDelay) {\n    options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n  }\n  if (options.from !== undefined) {\n    options.keyframes[0] = options.from;\n  }\n  let shouldSkip = false;\n  if (options.type === false || options.duration === 0 && !options.repeatDelay) {\n    options.duration = 0;\n    if (options.delay === 0) {\n      shouldSkip = true;\n    }\n  }\n  if (instantAnimationState.current || MotionGlobalConfig.skipAnimations) {\n    shouldSkip = true;\n    options.duration = 0;\n    options.delay = 0;\n  }\n  /**\n   * If the transition type or easing has been explicitly set by the user\n   * then we don't want to allow flattening the animation.\n   */\n  options.allowFlatten = !valueTransition.type && !valueTransition.ease;\n  /**\n   * If we can or must skip creating the animation, and apply only\n   * the final keyframe, do so. We also check once keyframes are resolved but\n   * this early check prevents the need to create an animation at all.\n   */\n  if (shouldSkip && !isHandoff && value.get() !== undefined) {\n    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n    if (finalKeyframe !== undefined) {\n      frame.update(() => {\n        options.onUpdate(finalKeyframe);\n        options.onComplete();\n      });\n      // We still want to return some animation controls here rather\n      // than returning undefined\n      return new GroupPlaybackControls([]);\n    }\n  }\n  /**\n   * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n   * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n   * optimised animation.\n   */\n  if (!isHandoff && AcceleratedAnimation.supports(options)) {\n    return new AcceleratedAnimation(options);\n  } else {\n    return new MainThreadAnimation(options);\n  }\n};\nexport { animateMotionValue };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}